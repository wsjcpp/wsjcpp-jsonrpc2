#!/usr/bin/env python3
# -*- coding: utf-8 -*-
### This file was automatically generated by wsjcpp-jsonrpc20
### Version: v0.0.4
### Date: Wed, 07 Oct 2020 02:05:13 GMT

import asyncio
import websocket
import json
import select
import time

class SomeClient:
    __ws = None
    __url = None
    __cli_version = 'v0.0.4'
    __loop = None
    __token = None
    __connecting = False
    __messageIdCounter = 0
    __incomingMesssages = []
    
    def __init__(self, url):
        self.__url = url
        self.__loop = asyncio.get_event_loop()
        try:
            self.__ws = websocket.create_connection(self.__url)
            self.__connecting = True
        except Exception as e:
            print('Failed connect to ' + self.__url)
            print('Exception: ' + str(e))
            self.__ws = None
            self.__connecting = False
            return
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.close()
    
    def hasConnection(self):
        return self.__ws != None
    
    def getToken(self):
        return self.__token
    
    def setToken(self, token):
        if self.__token is None:
            self.__token = token
        else:
            print('ERROR: Token can be set only once')
    
    def close(self):
        if self.__ws != None:
            self.__ws.close()
            self.__ws = None
    
    def receiveIncomingMesssages(self):
        if self.__ws is None:
            return None # TODO has not connection
        while True:
            if self.__ws is None:
                return None # TODO has not connection
            ready = select.select([self.__ws], [], [], 1)
            if ready[0]:
                responseText =  self.__ws.recv()
                responseJson = json.loads(responseText)
                # print('responseText: ' + responseText)
                # incomeMessageId = responseJson['m']
                self.__incomingMesssages.append(responseJson)
            else:
                return
            time.sleep(0.2)
    
    def getIncomingMesssages(self):
        return self.__incomingMesssages
    
    def clearIncomingMesssages(self):
        self.__incomingMesssages = []
    
    @asyncio.coroutine
    async def __looper(self, messageId):
        max_time = 5*10 # 5 seconds
        counter_time = 0
        while True:
            if self.__ws is None:
                return None # TODO has not connection
            for inmsg in self.__incomingMesssages:
                if inmsg['id'] == messageId:
                    responseJson = inmsg
                    self.__incomingMesssages.remove(responseJson)
                    return responseJson
            counter_time = counter_time + 1
            ready = select.select([self.__ws], [], [], 0.1)
            if ready[0]:
                responseText =  self.__ws.recv()
                responseJson = json.loads(responseText)
                # print('responseText: ' + responseText)
                if 'id' in responseJson:
                    incomeMessageId = responseJson['id']
                    if incomeMessageId == messageId:
                        return responseJson
                    else:
                        self.__incomingMesssages.append(responseJson)
                else:
                    print('What is it? ' + responseText)
            else:
                print('wait...')
            if counter_time > max_time:
                return None
            await asyncio.sleep(0.2)
    
    def generateBaseCommand(self, method):
        requestJson = {}
        self.__messageIdCounter = self.__messageIdCounter + 1
        msgId = 'id' + str(self.__messageIdCounter)
        requestJson['id'] = msgId
        requestJson['method'] = method
        requestJson['jsonrpc'] = '2.0'
        requestJson['params'] = {}
        return requestJson
    
    def __sendCommand(self, req):
        requestText = json.dumps(req)
        messageId = req['id']
        # print('requestText: ' + requestText)
        self.__ws.send(requestText) 
        result = self.__loop.run_until_complete(asyncio.gather(self.__looper(messageId)))
        result = self.preprocessIncomeJson(result[0])
        return result
    
    def preprocessIncomeJson(self, jsonIn):
        if jsonIn is None:
            return jsonIn
        if jsonIn['method'] == 'auth_logoff' and 'result' in jsonIn:
            self.__token = None
        if jsonIn['method'] == 'auth_login' and 'result' in jsonIn:
            self.__token = jsonIn['result']['token']
        if jsonIn['method'] == 'auth_token' and 'result' in jsonIn:
            self.__token = jsonIn['result']['token']
        return jsonIn
    
    def auth_login(self, login, password, client_app_name = None, client_app_version = None):
        """Auth by login and password
            
            Activated From Version: v0.0.2
            Allowed access for unauthorized users
            Denied access for users
            Denied access for tester
            Denied access for admins
            
            Args:
                login (string): required, User Login
                password (string): required, User Password
                client_app_name (string): optional, Client app name
                client_app_version (string): optional, Client app version
        """
        if not self.hasConnection(): return None
        reqJson = self.generateBaseCommand('auth_login')
        if login is None: 
            raise Exception('Parameter "login" expected (lib: SomeClient.auth_login)')
        if not isinstance(login, str): 
            raise Exception('Parameter "login" expected datatype "str" (lib: SomeClient.auth_login )')
        reqJson['params']['login'] = login
        if password is None: 
            raise Exception('Parameter "password" expected (lib: SomeClient.auth_login)')
        if not isinstance(password, str): 
            raise Exception('Parameter "password" expected datatype "str" (lib: SomeClient.auth_login )')
        reqJson['params']['password'] = password
        if client_app_name != None: 
            if not isinstance(client_app_name, str): 
                raise Exception('Parameter "client_app_name" expected datatype "str" (lib: SomeClient.auth_login )')
            reqJson['params']['client_app_name'] = client_app_name
        if client_app_version != None: 
            if not isinstance(client_app_version, str): 
                raise Exception('Parameter "client_app_version" expected datatype "str" (lib: SomeClient.auth_login )')
            reqJson['params']['client_app_version'] = client_app_version
        return self.__sendCommand(reqJson)
    
    def auth_logoff(self):
        """Logoff
            
            Activated From Version: v0.0.2
            Denied access for unauthorized users
            Allowed access for users
            Allowed access for tester
            Allowed access for admins
            
        """
        if not self.hasConnection(): return None
        reqJson = self.generateBaseCommand('auth_logoff')
        return self.__sendCommand(reqJson)
    
    def auth_token(self, token, client_app_name = None, client_app_version = None):
        """Auth by token
            
            Activated From Version: v0.0.2
            Allowed access for unauthorized users
            Denied access for users
            Denied access for tester
            Denied access for admins
            
            Args:
                token (string): required, Token
                client_app_name (string): optional, Client app name
                client_app_version (string): optional, Client app version
        """
        if not self.hasConnection(): return None
        reqJson = self.generateBaseCommand('auth_token')
        if token is None: 
            raise Exception('Parameter "token" expected (lib: SomeClient.auth_token)')
        if not isinstance(token, str): 
            raise Exception('Parameter "token" expected datatype "str" (lib: SomeClient.auth_token )')
        reqJson['params']['token'] = token
        if client_app_name != None: 
            if not isinstance(client_app_name, str): 
                raise Exception('Parameter "client_app_name" expected datatype "str" (lib: SomeClient.auth_token )')
            reqJson['params']['client_app_name'] = client_app_name
        if client_app_version != None: 
            if not isinstance(client_app_version, str): 
                raise Exception('Parameter "client_app_version" expected datatype "str" (lib: SomeClient.auth_token )')
            reqJson['params']['client_app_version'] = client_app_version
        return self.__sendCommand(reqJson)
    
    def game_create(self, uuid, cost, public, name = None, age = None, activated = None, custom = None):
        """Some example of description
            
            Activated From Version: v0.0.2
            Denied access for unauthorized users
            Allowed access for users
            Allowed access for tester
            Allowed access for admins
            
            Args:
                uuid (string): required, object uuid
                name (string): optional, Name of object
                cost (integer): required, Name of object
                age (integer): optional, Name of object
                public (boolean): required, True if object is public
                activated (boolean): optional, If object can handle
                custom (json): optional, Some custom json
        """
        if not self.hasConnection(): return None
        reqJson = self.generateBaseCommand('game_create')
        if uuid is None: 
            raise Exception('Parameter "uuid" expected (lib: SomeClient.game_create)')
        if not isinstance(uuid, str): 
            raise Exception('Parameter "uuid" expected datatype "str" (lib: SomeClient.game_create )')
        reqJson['params']['uuid'] = uuid
        if name != None: 
            if not isinstance(name, str): 
                raise Exception('Parameter "name" expected datatype "str" (lib: SomeClient.game_create )')
            reqJson['params']['name'] = name
        if cost is None: 
            raise Exception('Parameter "cost" expected (lib: SomeClient.game_create)')
        if not isinstance(cost, int): 
            raise Exception('Parameter "cost" expected datatype "int" (lib: SomeClient.game_create )')
        reqJson['params']['cost'] = cost
        if age != None: 
            if not isinstance(age, int): 
                raise Exception('Parameter "age" expected datatype "int" (lib: SomeClient.game_create )')
            reqJson['params']['age'] = age
        if public is None: 
            raise Exception('Parameter "public" expected (lib: SomeClient.game_create)')
        if not isinstance(public, bool): 
            raise Exception('Parameter "public" expected datatype "bool" (lib: SomeClient.game_create )')
        reqJson['params']['public'] = public
        if activated != None: 
            if not isinstance(activated, bool): 
                raise Exception('Parameter "activated" expected datatype "bool" (lib: SomeClient.game_create )')
            reqJson['params']['activated'] = activated
        if custom != None: 
            if not isinstance(custom, dict): 
                raise Exception('Parameter "custom" expected "dict" (lib: SomeClient.game_create )')
            reqJson['params']['custom'] = custom
        return self.__sendCommand(reqJson)
    
    def server_api(self):
        """This method Will be return list of all handlers
            
            Allowed access for unauthorized users
            Allowed access for users
            Allowed access for tester
            Allowed access for admins
            
        """
        if not self.hasConnection(): return None
        reqJson = self.generateBaseCommand('server_api')
        return self.__sendCommand(reqJson)
    
