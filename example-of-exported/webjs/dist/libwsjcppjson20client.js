// This file was automatically generated by wsjcpp-jsonrpc20 (v0.0.5), date: 10 Oct 2020
window.SomeClient = window.SomeClient || (function() { 
    var self = {};
    self.appName = 'wsjcpp-jsonrpc20';
    self.appVersion = 'v0.0.5';
    self.appBuildDate = '10 Oct 2020';
    var _lastm = 0;
    var _listeners = {};
    var _connectionState = '?';
    var _tokenValue = '';
    var _clientEvents = { 
        'connected': [],
        'reconnecting': [],
        'disconnected': [],
        'broken': [],
    };
    var _serverNotifications = { 
        'chat': [],
        'server': [],
    };
    function _lm() { _lastm++; return 'm' + _lastm; };
    console.warn('SomeClient (v0.0.5)');
    self.promise = function() {
        return {
            completed: false, failed: false, successed: false, 
            done: function(callback) {
                this.done_callback = callback;
                if (this.completed && typeof this.done_callback === 'function' && this.successed) {
                    this.done_callback.apply(this, this.result_arguments);
                }
                return this;
            },
            fail: function(callback) {
                this.fail_callback = callback;
                if (this.completed && typeof this.fail_callback === 'function' && this.failed) {
                    this.fail_callback.apply(this, this.error_arguments);
                }
                return this;
            },
            resolve: function() {
                if (!this.completed) {
                    this.result_arguments = arguments; // [];
                    if (typeof this.done_callback === 'function') {
                        this.done_callback.apply(this, this.result_arguments);
                    }
                }
                this.successed = true;
                this.completed = true;
            },
            reject: function() {
                if (!this.completed) {
                    this.error_arguments = arguments;
                    if (typeof this.fail_callback === 'function') {
                        this.fail_callback.apply(this, this.error_arguments);
                    }
                }
                this.failed = true;
                this.completed = true;
            }
        }; // end of promise
    };
    self.waitAllPromises = function(arr_promise) {
        var p = self.promise();
        var max_len = arr_promise.length;
        var result = [];
        function cmpl(r) {
            result.push(r);
            if (result.length == max_len) {
                p.resolve(result);
            }
        };
        for (var i in arr_promise) {
            arr_promise[i].done(cmpl).fail(cmpl);
        }
        return p;
    };
    self.setToken = function(token) {
        var date = new Date( new Date().getTime() + (7 * 24 * 60 * 60 * 1000) ); // cookie on week
        document.cookie = 'SomeClienttoken=' + encodeURIComponent(token) + '; path=/; expires='+date.toUTCString();
    }
    self.removeToken = function() {
        _tokenValue = '';        document.cookie = 'SomeClienttoken=; path=/;';
    }
    self.getToken = function() {
        var matches = document.cookie.match(new RegExp(
            '(?:^|; )' + 'SomeClienttoken'.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'
        ));
        return matches ? decodeURIComponent(matches[1]) : '';
    }
    _tokenValue = self.getToken();
    self.bindNotification = function(name, f) { _serverNotifications[name].push(f); }
    self.unbindNotification = function(name) { _serverNotifications[name] = []; }
    function _callNotification(name, data) {
        function __call(f, data) { setTimeout(function() { f(data) },1)}        for (var i = 0; i < _serverNotifications[name].length; i++) {
            __call(_serverNotifications[name][i], data);
        }
    }
    self.bindEvent = function(name, f) { _clientEvents[name].push(f); }
    self.unbindEvent = function(name) { _clientEvents[name] = []; }
    function _callEvent(name, data) {
        function __call(f, data) { setTimeout(function() { f(data) },1)}        for (var i = 0; i < _clientEvents[name].length; i++) {
            __call(_clientEvents[name][i], data);
        }
    }
    self.bindNotification('server', function(response) { 
       console.warn('All: ', response);
       if (response.app != self.appName) {
           console.error('AppName: ' + response.app + ', but expected ' + self.appName);
       }
       if (response.version != self.appVersion) {
           console.error('AppVersion: ' + response.version + ', but expected ' + self.appVersion);
       }
    }); 
    self.handleIncomeMessage = function(response) {
       var lstn = _listeners[response.id];
       if (lstn) {
           setTimeout(function() {
               if (response['error']) {
                   lstn.reject(response);
               } else {
                   lstn.resolve(response);
               }
               delete _listeners[response.id];
           },1);
        } else if (response.method === 'notification') {
            var nt_name = response.result['name'];
            if (_serverNotifications[nt_name]) {
                _callNotification(nt_name, response);
            }
       } else {
           console.error('Not found handler for [' + response.method + '/' + response.id + ']');
       }
   };
   self.send = function(obj, def) {
       obj.m = obj.m || _lm();
       _listeners[obj.m] = def || self.promise();
       try {
           if (self.socket.readyState == 0) {
               setTimeout(function() {
                   self.send(obj, _listeners[obj.m]);
               },1000);
           } else {
               self.socket.send(JSON.stringify(obj));
           }
       } catch(e) {
           console.error(e);
       }
       return _listeners[obj.m];
    }
    self.init = function(initParams) {
        if (!initParams.baseUrl) console.error('Expected baseUrl on initParams');
        self.socket = new WebSocket(initParams.baseUrl);
        self.socket.onopen = function() {
           console.log('WS Opened');
           _callEvent('connected', {});
           if (_tokenValue != '') self.token();
        };
        self.socket.onclose = function(event) {
           console.log('Closed');
           if (event.wasClean) {
               _callEvent('disconnected', {});
           } else {
               _callEvent('broken', {});
               setTimeout(function() {
                   _callEvent('reconnecting', {});
                   self.init(initParams);
               }, 10000);
             // Try reconnect after 5 sec
           }
           console.log('Code: ' + event.code + ' Reason: ' + event.reason);
       };
       self.socket.onmessage = function(event) {
           // console.log('Received: ' + event.data);
           try {
               var response = JSON.parse(event.data);
               self.handleIncomeMessage(response);
           } catch(e) {
               console.error(e);
           }
           
       };
       self.socket.onerror = function(error) {
           console.log('Error: ' + error.message);
       };
    }
    self.deinit = function(initParams) {
       self.removeToken();
       self.socket.close();
    }
   self.userProfile = {bInitUserProfile: false}
   self.updateUserProfileAsync = function() {
       setTimeout(function() {
           self.user().done(function(r) {
               self.userProfile.bInitUserProfile == true;
               self.userProfile.university = r.data.university;
               self.userProfile.country = r.data.country;
               self.userProfile.city = r.data.city;
               self.userinfo = {};
               self.userinfo.id = r.data.id;
               self.userinfo.nick = r.data.nick;
               self.userinfo.email = r.data.email;
               self.userinfo.role = r.data.role;
               self.userinfo.logo = r.data.logo;
               _call('userdata', r.data);
           }).fail(function() {
               self.removeToken();
               _call('userdata', {});
           });
       },10);
   }
    self.auth_login = function(params) {
       // Access unauthorized: yes
       // Access user: no
       // Access tester: no
       // Access admin: no
       // Activated From Version: v0.0.2
       // Input params:
       // * login - string, required (User Login) 
       // * password - string, required (User Password) 
       // * client_app_name - string, optional (Client app name) 
       // * client_app_version - string, optional (Client app version) 
        params = params || {};
        params.cmd = 'auth_login';
        if (params['login'] == undefined) {
             console.error('Parameter "login" expected (lib)');
        }
        if (params['password'] == undefined) {
             console.error('Parameter "password" expected (lib)');
        }
        return self.send(params);
    }

    self.auth_logoff = function(params) {
       // Access unauthorized: no
       // Access user: yes
       // Access tester: yes
       // Access admin: yes
       // Activated From Version: v0.0.2
        params = params || {};
        params.cmd = 'auth_logoff';
        return self.send(params);
    }

    self.auth_token = function(params) {
       // Access unauthorized: yes
       // Access user: no
       // Access tester: no
       // Access admin: no
       // Activated From Version: v0.0.2
       // Input params:
       // * token - string, required (Token) 
       // * client_app_name - string, optional (Client app name) 
       // * client_app_version - string, optional (Client app version) 
        params = params || {};
        params.cmd = 'auth_token';
        if (params['token'] == undefined) {
             console.error('Parameter "token" expected (lib)');
        }
        return self.send(params);
    }

    self.game_create = function(params) {
       // Access unauthorized: no
       // Access user: yes
       // Access tester: yes
       // Access admin: yes
       // Activated From Version: v0.0.2
       // Input params:
       // * uuid - string, required (object uuid) 
       // * name - string, optional (Name of object) 
       // * cost - integer, required (Name of object) 
       // * age - integer, optional (Name of object) 
       // * public - boolean, required (True if object is public) 
       // * activated - boolean, optional (If object can handle) 
       // * custom - json, optional (Some custom json) 
        params = params || {};
        params.cmd = 'game_create';
        if (params['uuid'] == undefined) {
             console.error('Parameter "uuid" expected (lib)');
        }
        if (params['cost'] == undefined) {
             console.error('Parameter "cost" expected (lib)');
        }
        if (params['public'] == undefined) {
             console.error('Parameter "public" expected (lib)');
        }
        return self.send(params);
    }

    self.server_api = function(params) {
       // Access unauthorized: yes
       // Access user: yes
       // Access tester: yes
       // Access admin: yes
        params = params || {};
        params.cmd = 'server_api';
        return self.send(params);
    }

    return self;
})();
